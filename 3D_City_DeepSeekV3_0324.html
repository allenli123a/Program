<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="dayWidth=device-width, initial-scale=1.0">
    <title>3D City Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 1px black;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">3D City Scene - Use mouse to look around, WASD to move, Q/E to go up/down</div>
    <div id="controls">
        <button id="toggleDayNight">Toggle Day/Night</button>
        <button id="toggleTrafficLights">Toggle Traffic Lights</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 50;
        controls.maxDistance = 300;
        controls.maxPolarAngle = Math.PI / 2;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // Street lights
        const streetLights = [];
        const streetLightGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
        const streetLightMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const streetLightTopGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const streetLightTopMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 });

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Roads and sidewalks
        function createRoad(x, z, width, length, rotation) {
            const roadGeometry = new THREE.PlaneGeometry(width, length);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0.01, z);
            road.rotation.y = rotation || 0;
            road.receiveShadow = true;
            scene.add(road);

            // Road markings
            const lineGeometry = new THREE.PlaneGeometry(width * 0.8, 0.5);
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 });
            
            if (rotation === 0 || rotation === Math.PI) {
                // Horizontal road
                for (let i = -length/2 + 5; i < length/2 - 5; i += 10) {
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(x, 0.02, z + i);
                    line.rotation.x = -Math.PI / 2;
                    scene.add(line);
                }
            } else {
                // Vertical road
                for (let i = -length/2 + 5; i < length/2 - 5; i += 10) {
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(x + i, 0.02, z);
                    line.rotation.x = -Math.PI / 2;
                    line.rotation.y = Math.PI / 2;
                    scene.add(line);
                }
            }

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(width + 4, length + 4);
            const sidewalkMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
            const sidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            sidewalk.rotation.x = -Math.PI / 2;
            sidewalk.position.set(x, 0.02, z);
            sidewalk.rotation.y = rotation || 0;
            scene.add(sidewalk);

            // Curb
            const curbGeometry = new THREE.BoxGeometry(width + 4.2, 0.2, length + 4.2);
            const curbMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const curb = new THREE.Mesh(curbGeometry, curbMaterial);
            curb.position.set(x, 0.12, z);
            scene.add(curb);

            // Street lights along the road
            const lightSpacing = 20;
            const lightOffset = 5;
            
            if (rotation === 0 || rotation === Math.PI) {
                // Horizontal road
                for (let i = -length/2 + 10; i < length/2 - 10; i += lightSpacing) {
                    const streetLight = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
                    const streetLightTop = new THREE.Mesh(streetLightTopGeometry, streetLightTopMaterial);
                    
                    streetLight.position.set(x - width/2 - 2, 2.5, z + i);
                    streetLightTop.position.set(x - width/2 - 2, 5.5, z + i);
                    
                    streetLight.castShadow = true;
                    streetLightTop.castShadow = true;
                    
                    const pointLight = new THREE.PointLight(0xFFFF00, 1, 20);
                    pointLight.position.set(x - width/2 - 2, 5, z + i);
                    pointLight.castShadow = true;
                    pointLight.shadow.mapSize.width = 512;
                    pointLight.shadow.mapSize.height = 512;
                    
                    scene.add(streetLight);
                    scene.add(streetLightTop);
                    scene.add(pointLight);
                    
                    streetLights.push({
                        light: pointLight,
                        top: streetLightTop,
                        active: true
                    });
                    
                    // Opposite side
                    const streetLight2 = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
                    const streetLightTop2 = new THREE.Mesh(streetLightTopGeometry, streetLightTopMaterial);
                    
                    streetLight2.position.set(x + width/2 + 2, 2.5, z + i);
                    streetLightTop2.position.set(x + width/2 + 2, 5.5, z + i);
                    
                    streetLight2.castShadow = true;
                    streetLightTop2.castShadow = true;
                    
                    const pointLight2 = new THREE.PointLight(0xFFFF00, 1, 20);
                    pointLight2.position.set(x + width/2 + 2, 5, z + i);
                    pointLight2.castShadow = true;
                    pointLight2.shadow.mapSize.width = 512;
                    pointLight2.shadow.mapSize.height = 512;
                    
                    scene.add(streetLight2);
                    scene.add(streetLightTop2);
                    scene.add(pointLight2);
                    
                    streetLights.push({
                        light: pointLight2,
                        top: streetLightTop2,
                        active: true
                    });
                }
            } else {
                // Vertical road
                for (let i = -length/2 + 10; i < length/2 - 10; i += lightSpacing) {
                    const streetLight = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
                    const streetLightTop = new THREE.Mesh(streetLightTopGeometry, streetLightTopMaterial);
                    
                    streetLight.position.set(x + i, 2.5, z - width/2 - 2);
                    streetLightTop.position.set(x + i, 5.5, z - width/2 - 2);
                    
                    streetLight.castShadow = true;
                    streetLightTop.castShadow = true;
                    
                    const pointLight = new THREE.PointLight(0xFFFF00, 1, 20);
                    pointLight.position.set(x + i, 5, z - width/2 - 2);
                    pointLight.castShadow = true;
                    pointLight.shadow.mapSize.width = 512;
                    pointLight.shadow.mapSize.height = 512;
                    
                    scene.add(streetLight);
                    scene.add(streetLightTop);
                    scene.add(pointLight);
                    
                    streetLights.push({
                        light: pointLight,
                        top: streetLightTop,
                        active: true
                    });
                    
                    // Opposite side
                    const streetLight2 = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
                    const streetLightTop2 = new THREE.Mesh(streetLightTopGeometry, streetLightTopMaterial);
                    
                    streetLight2.position.set(x + i, 2.5, z + width/2 + 2);
                    streetLightTop2.position.set(x + i, 5.5, z + width/2 + 2);
                    
                    streetLight2.castShadow = true;
                    streetLightTop2.castShadow = true;
                    
                    const pointLight2 = new THREE.PointLight(0xFFFF00, 1, 20);
                    pointLight2.position.set(x + i, 5, z + width/2 + 2);
                    pointLight2.castShadow = true;
                    pointLight2.shadow.mapSize.width = 512;
                    pointLight2.shadow.mapSize.height = 512;
                    
                    scene.add(streetLight2);
                    scene.add(streetLightTop2);
                    scene.add(pointLight2);
                    
                    streetLights.push({
                        light: pointLight2,
                        top: streetLightTop2,
                        active: true
                    });
                }
            }
        }

        // Create a grid of roads
        createRoad(0, 0, 20, 500, 0); // Main horizontal road
        createRoad(0, 0, 20, 500, Math.PI / 2); // Main vertical road

        for (let i = -200; i <= 200; i += 100) {
            if (i !== 0) {
                createRoad(i, 0, 15, 500, Math.PI / 2); // Vertical roads
                createRoad(0, i, 15, 500, 0); // Horizontal roads
            }
        }

        // Traffic lights
        const trafficLights = [];
        
        function createTrafficLight(x, z, rotation) {
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, 2.5, z);
            pole.castShadow = true;
            scene.add(pole);
            
            const boxGeometry = new THREE.BoxGeometry(1.5, 3, 0.5);
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(x, 5, z);
            box.rotation.y = rotation;
            box.castShadow = true;
            scene.add(box);
            
            // Lights
            const redLightGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const yellowLightGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const greenLightGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            
            const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 0 });
            const yellowLightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFFF00, emissiveIntensity: 0 });
            const greenLightMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00, emissive: 0x00FF00, emissiveIntensity: 0 });
            
            const redLight = new THREE.Mesh(redLightGeometry, redLightMaterial);
            const yellowLight = new THREE.Mesh(yellowLightGeometry, yellowLightMaterial);
            const greenLight = new THREE.Mesh(greenLightGeometry, greenLightMaterial);
            
            redLight.position.set(x, 6, z);
            yellowLight.position.set(x, 5, z);
            greenLight.position.set(x, 4, z);
            
            // Adjust positions based on rotation
            if (rotation === 0) {
                redLight.position.z += 0.5;
                yellowLight.position.z += 0.5;
                greenLight.position.z += 0.5;
            } else if (rotation === Math.PI / 2) {
                redLight.position.x += 0.5;
                yellowLight.position.x += 0.5;
                greenLight.position.x += 0.5;
            } else if (rotation === Math.PI) {
                redLight.position.z -= 0.5;
                yellowLight.position.z -= 0.5;
                greenLight.position.z -= 0.5;
            } else if (rotation === -Math.PI / 2) {
                redLight.position.x -= 0.5;
                yellowLight.position.x -= 0.5;
                greenLight.position.x -= 0.5;
            }
            
            scene.add(redLight);
            scene.add(yellowLight);
            scene.add(greenLight);
            
            trafficLights.push({
                red: redLight,
                yellow: yellowLight,
                green: greenLight,
                state: 'red', // 'red', 'yellow', 'green'
                timer: 0
            });
        }
        
        // Create traffic lights at intersections
        for (let i = -200; i <= 200; i += 100) {
            for (let j = -200; j <= 200; j += 100) {
                if (i !== 0 || j !== 0) {
                    // Northbound
                    createTrafficLight(i + 8, j, Math.PI / 2);
                    // Southbound
                    createTrafficLight(i - 8, j, -Math.PI / 2);
                    // Eastbound
                    createTrafficLight(i, j + 8, 0);
                    // Westbound
                    createTrafficLight(i, j - 8, Math.PI);
                }
            }
        }

        // Buildings
        function createBuilding(x, z, width, depth, height, color, isSkyscraper = false) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.1
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add windows
            const windowColor = isSkyscraper ? 0xADD8E6 : 0xF0E68C;
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: windowColor,
                emissive: windowColor,
                emissiveIntensity: Math.random() * 0.5
            });
            
            const windowWidth = width * 0.8 / 5;
            const windowHeight = height * 0.8 / (isSkyscraper ? 20 : 5);
            const windowDepth = 0.1;
            const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
            
            const windowSpacingX = width / 5;
            const windowSpacingY = height / (isSkyscraper ? 20 : 5);
            const startX = x - width / 2 + windowSpacingX / 2;
            const startY = height / (isSkyscraper ? 20 : 5) / 2;
            const startZ = z + depth / 2 + 0.1;
            
            for (let i = 0; i < (isSkyscraper ? 20 : 5); i++) {
                for (let j = 0; j < 5; j++) {
                    if (Math.random() > 0.3) { // Randomly place some windows
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            startX + j * windowSpacingX,
                            startY + i * windowSpacingY,
                            startZ
                        );
                        scene.add(window);
                        
                        // Add windows to the other side if it's a skyscraper
                        if (isSkyscraper) {
                            const windowBack = new THREE.Mesh(windowGeometry, windowMaterial);
                            windowBack.position.set(
                                startX + j * windowSpacingX,
                                startY + i * windowSpacingY,
                                z - depth / 2 - 0.1
                            );
                            scene.add(windowBack);
                            
                            // Add windows to the sides for skyscrapers
                            const windowRight = new THREE.Mesh(
                                new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth),
                                windowMaterial
                            );
                            windowRight.position.set(
                                x + width / 2 + 0.1,
                                startY + i * windowSpacingY,
                                z - depth / 2 + (j + 0.5) * windowSpacingX
                            );
                            scene.add(windowRight);
                            
                            const windowLeft = new THREE.Mesh(
                                new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth),
                                windowMaterial
                            );
                            windowLeft.position.set(
                                x - width / 2 - 0.1,
                                startY + i * windowSpacingY,
                                z - depth / 2 + (j + 0.5) * windowSpacingX
                            );
                            scene.add(windowLeft);
                        }
                    }
                }
            }
            
            return building;
        }

        // Create various buildings
        const buildings = [];
        const buildingColors = [
            0x8B4513, 0xA0522D, 0xD2691E, 0xCD853F, 0xD2B48C,
            0x708090, 0x778899, 0xB0C4DE, 0x4682B4, 0x5F9EA0
        ];
        
        // Skyscrapers in the center
        for (let i = -50; i <= 50; i += 40) {
            for (let j = -50; j <= 50; j += 40) {
                if (i !== 0 || j !== 0) {
                    const height = 60 + Math.random() * 40;
                    const width = 15 + Math.random() * 10;
                    const depth = 15 + Math.random() * 10;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    buildings.push(createBuilding(i, j, width, depth, height, color, true));
                }
            }
        }
        
        // Medium buildings in mid-range
        for (let i = -150; i <= 150; i += 60) {
            for (let j = -150; j <= 150; j += 60) {
                if (Math.abs(i) > 70 || Math.abs(j) > 70) {
                    const height = 20 + Math.random() * 20;
                    const width = 20 + Math.random() * 15;
                    const depth = 20 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    buildings.push(createBuilding(i, j, width, depth, height, color));
                }
            }
        }
        
        // Small shops and houses in outer areas
        for (let i = -200; i <= 200; i += 40) {
            for (let j = -200; j <= 200; j += 40) {
                if (Math.abs(i) > 120 || Math.abs(j) > 120) {
                    const height = 5 + Math.random() * 10;
                    const width = 10 + Math.random() * 15;
                    const depth = 10 + Math.random() * 15;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    buildings.push(createBuilding(i, j, width, depth, height, color));
                    
                    // Add some variety with slanted roofs for houses
                    if (Math.random() > 0.7) {
                        const roofGeometry = new THREE.ConeGeometry(width * 0.8, 5, 4);
                        const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                        roof.position.set(i, height + 2.5, j);
                        roof.rotation.y = Math.PI / 4;
                        scene.add(roof);
                    }
                }
            }
        }

        // Trees
        function createTree(x, z) {
            const trunkHeight = 2 + Math.random() * 2;
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            scene.add(trunk);
            
            const leavesRadius = 3 + Math.random() * 2;
            const leavesGeometry = new THREE.SphereGeometry(leavesRadius, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, trunkHeight + leavesRadius * 0.7, z);
            leaves.castShadow = true;
            scene.add(leaves);
            
            return { trunk, leaves };
        }
        
        const trees = [];
        for (let i = 0; i < 100; i++) {
            let x, z;
            do {
                x = -250 + Math.random() * 500;
                z = -250 + Math.random() * 500;
            } while (Math.abs(x) < 120 && Math.abs(z) < 120); // Avoid center
            
            trees.push(createTree(x, z));
        }

        // Benches
        function createBench(x, z, rotation) {
            const benchMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            // Bench legs
            const legGeometry = new THREE.BoxGeometry(0.3, 0.3, 1.5);
            const leg1 = new THREE.Mesh(legGeometry, benchMaterial);
            leg1.position.set(x - 0.8, 0.5, z);
            leg1.rotation.y = rotation;
            leg1.castShadow = true;
            scene.add(leg1);
            
            const leg2 = new THREE.Mesh(legGeometry, benchMaterial);
            leg2.position.set(x + 0.8, 0.5, z);
            leg2.rotation.y = rotation;
            leg2.castShadow = true;
            scene.add(leg2);
            
            // Bench seat
            const seatGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
            const seat = new THREE.Mesh(seatGeometry, benchMaterial);
            seat.position.set(x, 1, z);
            seat.rotation.y = rotation;
            seat.castShadow = true;
            scene.add(seat);
            
            // Bench back
            const backGeometry = new THREE.BoxGeometry(2, 1, 0.1);
            const back = new THREE.Mesh(backGeometry, benchMaterial);
            back.position.set(x, 1.5, z + (rotation === 0 ? 0.25 : -0.25));
            back.rotation.y = rotation;
            back.castShadow = true;
            scene.add(back);
        }
        
        // Place benches along sidewalks
        for (let i = -200; i <= 200; i += 80) {
            for (let j = -200; j <= 200; j += 80) {
                if (Math.random() > 0.5) {
                    createBench(i + 15, j, Math.PI / 2);
                    createBench(i - 15, j, -Math.PI / 2);
                    createBench(i, j + 15, 0);
                    createBench(i, j - 15, Math.PI);
                }
            }
        }

        // Cars
        class Car {
            constructor(x, z, direction) {
                this.width = 3 + Math.random() * 2;
                this.length = 6 + Math.random() * 2;
                this.height = 2 + Math.random();
                this.speed = 0.5 + Math.random();
                this.direction = direction; // 0: right, 1: up, 2: left, 3: down
                this.waiting = false;
                this.waitTime = 0;
                
                const bodyGeometry = new THREE.BoxGeometry(this.width, this.height, this.length);
                const bodyColor = new THREE.Color(
                    Math.random(),
                    Math.random(),
                    Math.random()
                );
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: bodyColor });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                const cabinGeometry = new THREE.BoxGeometry(this.width * 0.9, this.height * 0.6, this.length * 0.5);
                const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0.7 });
                this.cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
                this.cabin.position.y = this.height * 0.3;
                
                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                this.wheels = [];
                for (let i = 0; i < 4; i++) {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    this.wheels.push(wheel);
                }
                
                this.group = new THREE.Group();
                this.group.add(this.body);
                this.group.add(this.cabin);
                this.wheels.forEach(wheel => this.group.add(wheel));
                
                this.setPosition(x, z);
                this.updateWheels();
                
                this.group.castShadow = true;
                scene.add(this.group);
            }
            
            setPosition(x, z) {
                this.group.position.set(x, this.height / 2, z);
                
                // Adjust wheel positions based on car direction
                if (this.direction === 0 || this.direction === 2) {
                    // Horizontal movement
                    this.wheels[0].position.set(-this.width / 2 + 0.3, -this.height / 2 + 0.3, this.length / 3);
                    this.wheels[1].position.set(this.width / 2 - 0.3, -this.height / 2 + 0.3, this.length / 3);
                    this.wheels[2].position.set(-this.width / 2 + 0.3, -this.height / 2 + 0.3, -this.length / 3);
                    this.wheels[3].position.set(this.width / 2 - 0.3, -this.height / 2 + 0.3, -this.length / 3);
                } else {
                    // Vertical movement
                    this.wheels[0].position.set(this.length / 3, -this.height / 2 + 0.3, -this.width / 2 + 0.3);
                    this.wheels[1].position.set(this.length / 3, -this.height / 2 + 0.3, this.width / 2 - 0.3);
                    this.wheels[2].position.set(-this.length / 3, -this.height / 2 + 0.3, -this.width / 2 + 0.3);
                    this.wheels[3].position.set(-this.length / 3, -this.height / 2 + 0.3, this.width / 2 - 0.3);
                }
                
                // Set rotation based on direction
                this.group.rotation.y = this.direction * Math.PI / 2;
            }
            
            updateWheels() {
                this.wheels.forEach(wheel => {
                    wheel.rotation.x += this.speed * 0.1;
                });
            }
            
            update(delta) {
                if (this.waiting) {
                    this.waitTime += delta;
                    if (this.waitTime > 2) { // Wait for 2 seconds
                        this.waiting = false;
                        this.waitTime = 0;
                    }
                    return;
                }
                
                let newX = this.group.position.x;
                let newZ = this.group.position.z;
                
                switch (this.direction) {
                    case 0: // Right
                        newX += this.speed;
                        break;
                    case 1: // Up
                        newZ += this.speed;
                        break;
                    case 2: // Left
                        newX -= this.speed;
                        break;
                    case 3: // Down
                        newZ -= this.speed;
                        break;
                }
                
                // Check if car is at an intersection and needs to stop for red light
                const atIntersection = this.isAtIntersection();
                if (atIntersection) {
                    const trafficLight = this.getTrafficLightForDirection();
                    if (trafficLight && trafficLight.state === 'red') {
                        this.waiting = true;
                        return;
                    }
                }
                
                // Check if car is out of bounds
                if (newX < -250 || newX > 250 || newZ < -250 || newZ > 250) {
                    // Reset car on opposite side
                    if (newX < -250) newX = 250;
                    if (newX > 250) newX = -250;
                    if (newZ < -250) newZ = 250;
                    if (newZ > 250) newZ = -250;
                    
                    // Randomly change direction sometimes
                    if (Math.random() > 0.7) {
                        this.direction = Math.floor(Math.random() * 4);
                    }
                }
                
                this.setPosition(newX, newZ);
                this.updateWheels();
            }
            
            isAtIntersection() {
                const x = this.group.position.x;
                const z = this.group.position.z;
                
                // Check if car is near any intersection point (every 100 units)
                for (let i = -200; i <= 200; i += 100) {
                    for (let j = -200; j <= 200; j += 100) {
                        if (Math.abs(x - i) < 10 && Math.abs(z - j) < 10) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            getTrafficLightForDirection() {
                const x = this.group.position.x;
                const z = this.group.position.z;
                
                // Find the nearest intersection
                let nearestX = Math.round(x / 100) * 100;
                let nearestZ = Math.round(z / 100) * 100;
                
                // Get the traffic light for this car's direction
                let lightIndex = -1;
                
                if (this.direction === 0) { // Right
                    lightIndex = trafficLights.findIndex(light => 
                        Math.abs(light.green.position.x - (nearestX + 8)) < 1 &&
                        Math.abs(light.green.position.z - nearestZ) < 1
                    );
                } else if (this.direction === 1) { // Up
                    lightIndex = trafficLights.findIndex(light => 
                        Math.abs(light.green.position.x - nearestX) < 1 &&
                        Math.abs(light.green.position.z - (nearestZ + 8)) < 1
                    );
                } else if (this.direction === 2) { // Left
                    lightIndex = trafficLights.findIndex(light => 
                        Math.abs(light.green.position.x - (nearestX - 8)) < 1 &&
                        Math.abs(light.green.position.z - nearestZ) < 1
                    );
                } else if (this.direction === 3) { // Down
                    lightIndex = trafficLights.findIndex(light => 
                        Math.abs(light.green.position.x - nearestX) < 1 &&
                        Math.abs(light.green.position.z - (nearestZ - 8)) < 1
                    );
                }
                
                return lightIndex >= 0 ? trafficLights[lightIndex] : null;
            }
        }
        
        const cars = [];
        for (let i = 0; i < 30; i++) {
            let x, z, direction;
            
            // Place cars on roads (every 100 units)
            if (Math.random() > 0.5) {
                // Horizontal roads
                x = -250 + Math.random() * 500;
                z = Math.random() > 0.5 ? 
                    Math.floor(Math.random() * 5) * 100 : 
                    Math.floor(Math.random() * 5) * -100;
                direction = Math.random() > 0.5 ? 0 : 2; // Right or left
            } else {
                // Vertical roads
                x = Math.random() > 0.5 ? 
                    Math.floor(Math.random() * 5) * 100 : 
                    Math.floor(Math.random() * 5) * -100;
                z = -250 + Math.random() * 500;
                direction = Math.random() > 0.5 ? 1 : 3; // Up or down
            }
            
            cars.push(new Car(x, z, direction));
        }

        // Pedestrians
        class Pedestrian {
            constructor(x, z) {
                this.speed = 0.3 + Math.random() * 0.3;
                this.direction = Math.floor(Math.random() * 4); // 0: right, 1: up, 2: left, 3: down
                this.waiting = false;
                this.waitTime = 0;
                this.crossing = false;
                this.crossingStart = 0;
                this.targetX = 0;
                this.targetZ = 0;
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 1.7;
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 0.9;
                
                // Legs
                const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const legMaterial = new THREE.MeshStandardMaterial({ color: 0x000080 });
                
                this.legs = [];
                for (let i = 0; i < 2; i++) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.x = i === 0 ? -0.15 : 0.15;
                    leg.position.y = 0.4;
                    this.legs.push(leg);
                }
                
                // Arms
                const armGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4 });
                
                this.arms = [];
                for (let i = 0; i < 2; i++) {
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.x = i === 0 ? -0.4 : 0.4;
                    arm.position.y = 1.1;
                    this.arms.push(arm);
                }
                
                this.group = new THREE.Group();
                this.group.add(this.head);
                this.group.add(this.body);
                this.legs.forEach(leg => this.group.add(leg));
                this.arms.forEach(arm => this.group.add(arm));
                
                this.setPosition(x, z);
                
                this.group.castShadow = true;
                scene.add(this.group);
            }
            
            setPosition(x, z) {
                this.group.position.set(x, 0, z);
                
                // Animate legs when walking
                if (!this.waiting && !this.crossing) {
                    const legAngle = Math.sin(Date.now() * 0.01) * 0.5;
                    this.legs[0].rotation.x = legAngle;
                    this.legs[1].rotation.x = -legAngle;
                    
                    const armAngle = Math.sin(Date.now() * 0.01) * 0.3;
                    this.arms[0].rotation.x = -armAngle;
                    this.arms[1].rotation.x = armAngle;
                }
            }
            
            update(delta) {
                if (this.waiting) {
                    this.waitTime += delta;
                    if (this.waitTime > 1) { // Wait for 1 second
                        this.waiting = false;
                        this.waitTime = 0;
                        
                        // Decide whether to cross
                        if (Math.random() > 0.7 && this.isAtCrosswalk()) {
                            this.startCrossing();
                        } else {
                            // Change direction randomly
                            if (Math.random() > 0.8) {
                                this.direction = Math.floor(Math.random() * 4);
                            }
                        }
                    }
                    return;
                }
                
                if (this.crossing) {
                    // Move towards target
                    const dx = this.targetX - this.group.position.x;
                    const dz = this.targetZ - this.group.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 0.2) {
                        this.crossing = false;
                    } else {
                        const newX = this.group.position.x + (dx / distance) * this.speed;
                        const newZ = this.group.position.z + (dz / distance) * this.speed;
                        this.setPosition(newX, newZ);
                    }
                    return;
                }
                
                let newX = this.group.position.x;
                let newZ = this.group.position.z;
                
                switch (this.direction) {
                    case 0: // Right
                        newX += this.speed;
                        break;
                    case 1: // Up
                        newZ += this.speed;
                        break;
                    case 2: // Left
                        newX -= this.speed;
                        break;
                    case 3: // Down
                        newZ -= this.speed;
                        break;
                }
                
                // Check if pedestrian is at a crosswalk
                if (this.isAtCrosswalk() && Math.random() > 0.99) {
                    this.waiting = true;
                    return;
                }
                
                // Check if pedestrian is out of bounds or should change direction
                if (newX < -240 || newX > 240 || newZ < -240 || newZ > 240 || Math.random() > 0.995) {
                    this.waiting = true;
                    return;
                }
                
                this.setPosition(newX, newZ);
            }
            
            isAtCrosswalk() {
                const x = this.group.position.x;
                const z = this.group.position.z;
                
                // Check if near an intersection (every 100 units)
                for (let i = -200; i <= 200; i += 100) {
                    for (let j = -200; j <= 200; j += 100) {
                        if (Math.abs(x - i) < 15 && Math.abs(z - j) < 15) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            startCrossing() {
                this.crossing = true;
                this.crossingStart = Date.now();
                
                // Set target to opposite side of the road
                const currentX = this.group.position.x;
                const currentZ = this.group.position.z;
                
                // Find nearest intersection center
                const nearestX = Math.round(currentX / 100) * 100;
                const nearestZ = Math.round(currentZ / 100) * 100;
                
                // Choose a direction to cross (perpendicular to current direction)
                const crossDirection = Math.floor(Math.random() * 2) * 2; // 0 or 2
                
                if (this.direction === 0 || this.direction === 2) {
                    // Currently moving horizontally, cross vertically
                    this.targetX = nearestX;
                    this.targetZ = nearestZ + (crossDirection === 0 ? 15 : -15);
                } else {
                    // Currently moving vertically, cross horizontally
                    this.targetX = nearestX + (crossDirection === 0 ? 15 : -15);
                    this.targetZ = nearestZ;
                }
            }
        }
        
        const pedestrians = [];
        for (let i = 0; i < 50; i++) {
            let x, z;
            
            // Place pedestrians on sidewalks
            if (Math.random() > 0.5) {
                // Horizontal sidewalks
                x = -240 + Math.random() * 480;
                z = Math.random() > 0.5 ? 
                    12 + Math.floor(Math.random() * 5) * 100 : 
                    -12 + Math.floor(Math.random() * 5) * -100;
            } else {
                // Vertical sidewalks
                x = Math.random() > 0.5 ? 
                    12 + Math.floor(Math.random() * 5) * 100 : 
                    -12 + Math.floor(Math.random() * 5) * -100;
                z = -240 + Math.random() * 480;
            }
            
            pedestrians.push(new Pedestrian(x, z));
        }

        // Day/night cycle
        let isDay = true;
        let dayCycleSpeed = 0.001;
        let dayTime = 0;
        
        function toggleDayNight() {
            isDay = !isDay;
            if (isDay) {
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
                sunLight.intensity = 1;
                ambientLight.intensity = 0.4;
            } else {
                scene.background = new THREE.Color(0x000033); // Dark blue
                scene.fog = new THREE.Fog(0x000033, 50, 300);
                sunLight.intensity = 0.1;
                ambientLight.intensity = 0.1;
            }
            
            // Toggle street lights
            streetLights.forEach(light => {
                light.light.intensity = isDay ? 0 : 1;
                light.top.material.emissiveIntensity = isDay ? 0 : 0.5;
            });
            
            // Toggle building windows
            buildings.forEach(building => {
                building.traverse(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissiveIntensity = isDay ? 
                            Math.random() * 0.5 : 
                            Math.random() > 0.3 ? 1 : 0;
                    }
                });
            });
        }
        
        // Traffic light control
        let trafficLightTimer = 0;
        let trafficLightState = 'red';
        let trafficLightsActive = true;
        
        function toggleTrafficLights() {
            trafficLightsActive = !trafficLightsActive;
            if (!trafficLightsActive) {
                // Set all to yellow blinking
                trafficLights.forEach(light => {
                    light.red.material.emissiveIntensity = 0;
                    light.yellow.material.emissiveIntensity = 0.5;
                    light.green.material.emissiveIntensity = 0;
                    light.state = 'yellow';
                });
            }
        }
        
        // Event listeners
        document.getElementById('toggleDayNight').addEventListener('click', toggleDayNight);
        document.getElementById('toggleTrafficLights').addEventListener('click', toggleTrafficLights);
        
        // Animation loop
        let lastTime = 0;
        function animate(currentTime = 0) {
            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update controls
            controls.update();
            
            // Update day/night cycle
            dayTime += delta * dayCycleSpeed;
            sunLight.position.x = Math.cos(dayTime) * 200;
            sunLight.position.z = Math.sin(dayTime) * 200;
            
            // Update traffic lights
            if (trafficLightsActive) {
                trafficLightTimer += delta;
                if (trafficLightTimer > 10) { // Change every 10 seconds
                    trafficLightTimer = 0;
                    trafficLightState = trafficLightState === 'red' ? 'green' : 'red';
                    
                    trafficLights.forEach(light => {
                        // Yellow transition
                        light.state = 'yellow';
                        light.red.material.emissiveIntensity = 0;
                        light.yellow.material.emissiveIntensity = 1;
                        light.green.material.emissiveIntensity = 0;
                        light.timer = 0;
                    });
                } else if (trafficLightTimer > 2 && trafficLights[0]?.state === 'yellow') {
                    // After 2 seconds of yellow, switch to the new state
                    trafficLights.forEach(light => {
                        light.state = trafficLightState;
                        light.red.material.emissiveIntensity = trafficLightState === 'red' ? 1 : 0;
                        light.yellow.material.emissiveIntensity = 0;
                        light.green.material.emissiveIntensity = trafficLightState === 'green' ? 1 : 0;
                    });
                }
            } else {
                // Blinking yellow lights
                trafficLights.forEach(light => {
                    light.yellow.material.emissiveIntensity = Math.abs(Math.sin(currentTime * 0.005));
                });
            }
            
            // Update cars
            cars.forEach(car => car.update(delta));
            
            // Update pedestrians
            pedestrians.forEach(ped => ped.update(delta));
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
