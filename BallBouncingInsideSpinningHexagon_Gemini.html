<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Spinning Hexagon</title>
    <!-- Include the p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script> --> <!-- Optional: if you add sound -->

    <style>
        /* Basic CSS to center the canvas and remove margins */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #222; /* Dark background */
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            border: 1px solid #555; /* Optional border for the canvas */
        }
    </style>
</head>
<body>
    <!-- p5.js sketch will be created here -->
    <script>
        // --- Sketch Variables ---
        let ball;
        let hexagon;
        let gravity;
        let restitution = 0.8; // Bounciness (0 = no bounce, 1 = perfect bounce)

        // --- Ball Class ---
        class Ball {
            constructor(x, y, r) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-2, 2), random(-2, 2)); // Initial velocity
                this.acc = createVector(0, 0);
                this.r = r;
                this.mass = this.r * 0.1; // Mass proportional to radius
                this.color = color(255, 100, 100);
            }

            applyForce(force) {
                // Newton's second law: F = ma -> a = F/m
                let f = p5.Vector.div(force, this.mass);
                this.acc.add(f);
            }

            applyGravity() {
                 // Apply gravity force (mass * gravity vector)
                 this.applyForce(p5.Vector.mult(gravity, this.mass));
            }

            update() {
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                // Reset acceleration each frame after applying it
                this.acc.mult(0);
            }

            display() {
                noStroke();
                fill(this.color);
                ellipse(this.pos.x, this.pos.y, this.r * 2, this.r * 2);
            }

            // --- The Core Collision Logic with Rotating Walls ---
            checkCollision(hexagon) {
                let vertices = hexagon.getVertices();
                let collidedThisFrame = false; // Prevent multiple impulse applications per frame

                for (let i = 0; i < vertices.length; i++) {
                    if (collidedThisFrame) break; // Process only the first detected collision

                    let v1 = vertices[i];
                    let v2 = vertices[(i + 1) % vertices.length]; // Next vertex, wrapping around

                    // --- 1. Find the closest point on the line segment (hexagon side) to the ball's center ---
                    let lineVec = p5.Vector.sub(v2, v1);         // Vector representing the side
                    let pointVec = p5.Vector.sub(this.pos, v1); // Vector from side start to ball center
                    let lineLenSq = lineVec.magSq();             // Squared length of the side

                    // Project pointVec onto lineVec to find the parameter 't'
                    // t = dot(pointVec, lineVec) / |lineVec|^2
                    let t = p5.Vector.dot(pointVec, lineVec) / lineLenSq;

                    // Clamp 't' to be between 0 and 1 to stay on the segment
                    t = constrain(t, 0, 1);

                    // Calculate the closest point on the segment
                    let closestPoint = p5.Vector.add(v1, p5.Vector.mult(lineVec, t));

                    // --- 2. Check the distance between the ball center and the closest point ---
                    let distVec = p5.Vector.sub(this.pos, closestPoint);
                    let distance = distVec.mag();

                    // --- 3. Collision Detected if distance is less than ball's radius ---
                    if (distance < this.r) {
                        collidedThisFrame = true; // Mark collision for this frame

                        // --- 4. Calculate the Collision Normal ---
                        // The normal vector is perpendicular to the side, pointing outwards
                        let normal = createVector(lineVec.y, -lineVec.x);
                        normal.normalize();
                        // Ensure normal points *away* from the hexagon's center
                        // Check dot product with a vector from center to a point on the line (e.g., v1)
                        let centerToV1 = p5.Vector.sub(v1, createVector(hexagon.cx, hexagon.cy));
                        if (p5.Vector.dot(normal, centerToV1) < 0) {
                            normal.mult(-1); // Flip normal if it points inwards
                        }

                        // --- 5. Calculate the Velocity of the Wall at the Collision Point ---
                        // Vector from hexagon center to the collision point
                        let rVec = p5.Vector.sub(closestPoint, createVector(hexagon.cx, hexagon.cy));
                        let omega = hexagon.angleSpeed; // Angular velocity (radians/frame)
                        // Tangential velocity formula: v_tangential = omega x r (cross product)
                        // In 2D, this simplifies to: (-omega * r.y, omega * r.x)
                        let wallVel = createVector(-omega * rVec.y, omega * rVec.x);

                        // --- 6. Calculate Relative Velocity (Ball's velocity relative to the wall's velocity) ---
                        let relativeVel = p5.Vector.sub(this.vel, wallVel);

                        // --- 7. Check if the ball is moving towards the wall ---
                        // If the dot product of relative velocity and normal is negative, they are moving towards each other.
                        let velAlongNormal = p5.Vector.dot(relativeVel, normal);

                        if (velAlongNormal < 0) { // Only bounce if moving towards the wall

                            // --- 8. Calculate Impulse Magnitude ---
                            // Impulse formula for collision with restitution:
                            // j = -(1 + e) * (v_rel . n) / (1/m1 + 1/m2)
                            // Assuming wall has infinite mass (1/m2 -> 0)
                            // j = -(1 + e) * (v_rel . n) / (1/m_ball)
                            // j = -mass * (1 + e) * (v_rel . n)
                            // Note: velAlongNormal = (v_rel . n)
                            let j = -(1 + restitution) * velAlongNormal;
                            j /= (1 / this.mass); // Scale by inverse mass (correct impulse calculation)

                            // --- 9. Apply Impulse to the Ball's Velocity ---
                            // Impulse vector J = j * n
                            // Change in velocity delta_v = J / mass = (j * n) / mass
                            let impulseVec = p5.Vector.mult(normal, j);
                            this.vel.add(p5.Vector.div(impulseVec, this.mass));

                            // --- 10. Position Correction (to prevent sinking/sticking) ---
                            // Move the ball slightly out of the wall along the normal
                            let overlap = this.r - distance;
                            // Apply correction slightly larger than overlap to push it out firmly
                            this.pos.add(p5.Vector.mult(normal, overlap * 1.01));
                        }
                    }
                }
            }
        } // End Ball Class

        // --- Hexagon Class ---
        class Hexagon {
            constructor(cx, cy, r, angleSpeed) {
                this.cx = cx;
                this.cy = cy;
                this.r = r; // Radius from center to vertex
                this.angle = 0; // Current rotation angle in radians
                this.angleSpeed = angleSpeed; // Rotation speed in radians per frame
                this.numVertices = 6;
                this.strokeColor = color(255); // White outline
            }

            update() {
                // Increment the angle to rotate
                this.angle += this.angleSpeed;
            }

            getVertices() {
                // Calculate the current positions of the 6 vertices
                let vertices = [];
                for (let i = 0; i < this.numVertices; i++) {
                    // Calculate the angle for this vertex
                    let currentAngle = this.angle + TWO_PI / this.numVertices * i;
                    // Calculate vertex coordinates using trigonometry
                    let vx = this.cx + this.r * cos(currentAngle);
                    let vy = this.cy + this.r * sin(currentAngle);
                    vertices.push(createVector(vx, vy));
                }
                return vertices;
            }

            display() {
                let vertices = this.getVertices();
                stroke(this.strokeColor);
                strokeWeight(2);
                noFill(); // Make the hexagon hollow
                beginShape();
                for (let v of vertices) {
                    vertex(v.x, v.y);
                }
                endShape(CLOSE); // Connect the last vertex to the first
            }
        } // End Hexagon Class

        // --- p5.js Main Functions ---

        function setup() {
            // Create canvas, make it slightly smaller than window if needed
            let canvasSize = min(windowWidth - 40, windowHeight - 40, 600);
            createCanvas(canvasSize, canvasSize);

            // Define gravity vector (adjust Y value for strength)
            gravity = createVector(0, 0.2);

            // Initialize the hexagon
            let hexRadius = width / 2.5; // Make hexagon fill a good portion of canvas
            let hexAngleSpeed = 0.005;    // Rotation speed (radians per frame)
            hexagon = new Hexagon(width / 2, height / 2, hexRadius, hexAngleSpeed);

            // Initialize the ball
            let ballRadius = 15;
            ball = new Ball(width / 2, height / 2, ballRadius);

             // Optional: Give the ball an initial random push
             // ball.applyForce(createVector(random(-50, 50), random(-50, -10)));
        }

        function draw() {
            background(50); // Use a dark gray background

            // --- Update Phase ---
            hexagon.update();      // Rotate the hexagon
            ball.applyGravity();   // Apply gravity force to the ball
            ball.update();         // Update ball's velocity and position

            // --- Collision Phase ---
            ball.checkCollision(hexagon); // Check and handle collisions

            // --- Display Phase ---
            hexagon.display();     // Draw the hexagon
            ball.display();        // Draw the ball

            // Optional: Display frame rate for debugging
            // fill(255);
            // noStroke();
            // textSize(12);
            // text("FPS: " + floor(frameRate()), 10, 20);
        }

        // Optional: Resize canvas if window is resized
        // function windowResized() {
        //    let canvasSize = min(windowWidth - 40, windowHeight - 40, 600);
        //    resizeCanvas(canvasSize, canvasSize);
        //    // May need to reset object positions if canvas size changes drastically
        //    // hexagon.cx = width/2; hexagon.cy = height/2;
        //    // ball.pos = createVector(width/2, height/2); // Reset ball to center
        // }

    </script>
</body>
</html>
