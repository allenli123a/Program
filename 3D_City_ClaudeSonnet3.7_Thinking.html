<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">3D City Scene - Use mouse to navigate</div>
    <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene, camera, renderer setup
        let scene, camera, renderer, controls;
        let clock = new THREE.Clock();

        // City objects
        let buildings = [];
        let cars = [];
        let pedestrians = [];
        let trafficLights = [];

        // Time of day
        let dayTime = 12; // 0-24 hours
        let dayNightCycle = true;

        init();
        animate();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent camera from going below ground

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Setup lighting
            setupLighting();

            // Create city elements
            createGround();
            createBuildings();
            createRoads();
            createStreetElements();
            createCars();
            createTrafficLights();
            createPedestrians();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Increase ambient light
            scene.add(ambientLight);

            // Main directional light (sun) - keep this as the primary light source
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);

            // Store the main light for day/night cycle
            scene.userData.sunLight = sunLight;

            // Add a few strategic point lights at key intersections instead of many small lights
            const citySize = 5; // Match your gridSize
            const spacing = 18; // blockSize + roadWidth

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const areaLight = new THREE.PointLight(0xffffcc, 0.8, 50);
                    areaLight.position.set(i * spacing * 2, 15, j * spacing * 2);
                    scene.add(areaLight);
                }
            }
        }

        function createGround() {
            // Create a large flat plane for the ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a3300,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be flat
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createBuildings() {
            // Define city grid size
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            // CRITICAL FIX: Create a map of road positions to avoid building placement there
            const roadPositions = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                roadPositions.push(i * (blockSize + roadWidth));
            }

            // Create buildings in a grid pattern - but only in valid building blocks
            for (let x = -gridSize; x <= gridSize - 1; x++) {
                for (let z = -gridSize; z <= gridSize - 1; z++) {
                    // Calculate block center position - but NOW we'll offset to be in the center of actual blocks
                    // This ensures buildings are between roads, not on them
                    const blockCenterX = x * (blockSize + roadWidth) + (blockSize + roadWidth)/2;
                    const blockCenterZ = z * (blockSize + roadWidth) + (blockSize + roadWidth)/2;

                    // MORE RESTRICTIVE safety margin
                    const safetyMargin = 3; // Increased from 2 to 3
                    const maxBuildingWidth = blockSize - safetyMargin * 2;
                    const maxBuildingDepth = blockSize - safetyMargin * 2;

                    // Skip some positions for variety
                    if (Math.random() < 0.1) continue;

                    // Decide building type based on position and randomness
                    const distanceFromCenter = Math.sqrt(x*x + z*z);

                    if (distanceFromCenter < 2) {
                        // Downtown area - skyscrapers
                        createSkyscraper(blockCenterX, blockCenterZ, maxBuildingWidth, maxBuildingDepth);
                    } else if (distanceFromCenter < 4) {
                        // Mid city - mix of buildings
                        if (Math.random() < 0.3) {
                            createSkyscraper(blockCenterX, blockCenterZ, maxBuildingWidth, maxBuildingDepth);
                        } else {
                            createApartmentBuilding(blockCenterX, blockCenterZ, maxBuildingWidth, maxBuildingDepth);
                        }
                    } else {
                        // Outer city - mostly apartments and shops
                        if (Math.random() < 0.7) {
                            createApartmentBuilding(blockCenterX, blockCenterZ, maxBuildingWidth, maxBuildingDepth);
                        } else {
                            createShop(blockCenterX, blockCenterZ, maxBuildingWidth, maxBuildingDepth);
                        }
                    }
                }
            }
        }

        function createSkyscraper(x, z, maxWidth, maxDepth) {
            // Random properties with strict size limits
            const width = Math.min(4 + Math.random() * 2, maxWidth);
            const depth = Math.min(4 + Math.random() * 2, maxDepth);
            const height = 15 + Math.random() * 25;

            // Base building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,
                specular: 0x111111,
                shininess: 30
            });

            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            buildings.push(building);

            // Add windows as a grid pattern
            const windowSize = 0.5;
            const windowSpacing = 1.2;
            const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffcc,
                emissive: 0x555533,
                side: THREE.DoubleSide
            });

            // Add windows to all four sides
            const sides = [
                { dir: 'front', rot: [0, 0, 0], pos: [0, 0, depth/2 + 0.01] },
                { dir: 'back', rot: [0, Math.PI, 0], pos: [0, 0, -depth/2 - 0.01] },
                { dir: 'left', rot: [0, -Math.PI/2, 0], pos: [-width/2 - 0.01, 0, 0] },
                { dir: 'right', rot: [0, Math.PI/2, 0], pos: [width/2 + 0.01, 0, 0] }
            ];

            sides.forEach(side => {
                const windowsWide = Math.floor(side.dir === 'front' || side.dir === 'back' ? width / windowSpacing : depth / windowSpacing);
                const windowsTall = Math.floor(height / windowSpacing);

                for (let wx = 0; wx < windowsWide; wx++) {
                    for (let wy = 0; wy < windowsTall; wy++) {
                        // Skip some windows randomly
                        if (Math.random() < 0.3) continue;

                        const window = new THREE.Mesh(windowGeometry, windowMaterial.clone());

                        // Calculate position
                        let wx_pos, wy_pos, wz_pos;

                        if (side.dir === 'front' || side.dir === 'back') {
                            wx_pos = (wx - windowsWide/2 + 0.5) * windowSpacing;
                            wy_pos = (wy - windowsTall/2 + 0.5) * windowSpacing + height/2;
                            wz_pos = side.pos[2];
                            window.position.set(x + wx_pos, wy_pos, z + wz_pos);
                        } else {
                            wx_pos = side.pos[0];
                            wy_pos = (wy - windowsTall/2 + 0.5) * windowSpacing + height/2;
                            wz_pos = (wx - windowsWide/2 + 0.5) * windowSpacing;
                            window.position.set(x + wx_pos, wy_pos, z + wz_pos);
                        }

                        window.rotation.set(side.rot[0], side.rot[1], side.rot[2]);
                        scene.add(window);

                        // Store reference to parent building
                        window.userData.buildingType = 'skyscraper';
                        window.userData.parentBuilding = building;
                    }
                }
            });
        }

        function createApartmentBuilding(x, z, maxWidth, maxDepth) {
            // Random properties with strict size limits
            const width = Math.min(4 + Math.random() * 2, maxWidth);
            const depth = Math.min(4 + Math.random() * 2, maxDepth);
            const height = 8 + Math.random() * 7;

            // Create base building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const color = new THREE.Color(0.6 + Math.random() * 0.2, 0.6 + Math.random() * 0.2, 0.6 + Math.random() * 0.2);
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7
            });

            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            buildings.push(building);

            // Add a simple roof
            const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.6, 2, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(x, height + 1, z);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            scene.add(roof);

            // Add windows
            const windowSize = 0.8;
            const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize * 1.5);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xadd8e6,
                emissive: 0x333333,
                side: THREE.DoubleSide
            });

            // Add windows to front and back
            const windowRows = Math.floor(height / 2);
            const windowCols = Math.floor(width / 1.5);

            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    // Front windows
                    const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                    frontWindow.position.set(
                        x + (col - windowCols/2 + 0.5) * 1.5,
                        (row + 0.5) * 2 + 1,
                        z + depth/2 + 0.01
                    );
                    scene.add(frontWindow);

                    // Back windows
                    const backWindow = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                    backWindow.position.set(
                        x + (col - windowCols/2 + 0.5) * 1.5,
                        (row + 0.5) * 2 + 1,
                        z - depth/2 - 0.01
                    );
                    backWindow.rotation.y = Math.PI;
                    scene.add(backWindow);
                }
            }
        }

        function createShop(x, z, maxWidth, maxDepth) {
            // Random properties with strict size limits
            const width = Math.min(3 + Math.random() * 1.5, maxWidth);
            const depth = Math.min(3 + Math.random() * 1.5, maxDepth);
            const height = 3 + Math.random() * 1.5;

            // Create base shop building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);

            // Random store colors
            const colors = [0xf4a460, 0xd2b48c, 0xcd853f, 0xa0522d, 0x8b4513];
            const color = colors[Math.floor(Math.random() * colors.length)];

            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8
            });

            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            buildings.push(building);

            // Add a storefront with large windows
            const storefrontGeometry = new THREE.PlaneGeometry(width * 0.8, height * 0.6);
            const storefrontMaterial = new THREE.MeshPhongMaterial({
                color: 0xadd8e6,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });

            // Add storefront to the front and back sides
            const storefront1 = new THREE.Mesh(storefrontGeometry, storefrontMaterial);
            storefront1.position.set(x, height * 0.4, z + depth/2 + 0.01);
            scene.add(storefront1);

            const storefront2 = new THREE.Mesh(storefrontGeometry, storefrontMaterial);
            storefront2.position.set(x, height * 0.4, z - depth/2 - 0.01);
            storefront2.rotation.y = Math.PI;
            scene.add(storefront2);

            // Add a simple awning
            const awningGeometry = new THREE.BoxGeometry(width, 0.2, 1);
            const awningMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000 + Math.floor(Math.random() * 0xffff00)
            });

            const awning1 = new THREE.Mesh(awningGeometry, awningMaterial);
            awning1.position.set(x, height * 0.7, z + depth/2 + 0.5);
            awning1.castShadow = true;
            scene.add(awning1);

            const awning2 = new THREE.Mesh(awningGeometry, awningMaterial);
            awning2.position.set(x, height * 0.7, z - depth/2 - 0.5);
            awning2.castShadow = true;
            scene.add(awning2);

            // Add a door
            const doorGeometry = new THREE.PlaneGeometry(1, 2);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                side: THREE.DoubleSide
            });

            const door1 = new THREE.Mesh(doorGeometry, doorMaterial);
            door1.position.set(x, 1, z + depth/2 + 0.02);
            scene.add(door1);

            const door2 = new THREE.Mesh(doorGeometry, doorMaterial);
            door2.position.set(x, 1, z - depth/2 - 0.02);
            door2.rotation.y = Math.PI;
            scene.add(door2);
        }

        function createRoads() {
            // Create a grid of roads
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;
            const roadMarkerWidth = 0.5;
            const roadMarkerLength = 2;
            const roadMarkerGap = 2;

            // Create the road material
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9
            });

            // Create road marker material
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5
            });

            // Create horizontal and vertical roads
            for (let i = -gridSize; i <= gridSize; i++) {
                // Horizontal road
                const horizontalRoad = new THREE.Mesh(
                    new THREE.PlaneGeometry(200, roadWidth),
                    roadMaterial
                );
                horizontalRoad.rotation.x = -Math.PI / 2;
                horizontalRoad.position.set(0, 0, i * (blockSize + roadWidth));
                horizontalRoad.receiveShadow = true;
                scene.add(horizontalRoad);

                // Vertical road
                const verticalRoad = new THREE.Mesh(
                    new THREE.PlaneGeometry(roadWidth, 200),
                    roadMaterial
                );
                verticalRoad.rotation.x = -Math.PI / 2;
                verticalRoad.position.set(i * (blockSize + roadWidth), 0, 0);
                verticalRoad.receiveShadow = true;
                scene.add(verticalRoad);

                // Road markers (dashed lines in the middle of roads)
                for (let j = -10; j <= 10; j++) {
                    // Horizontal road markers
                    const hMarker = new THREE.Mesh(
                        new THREE.PlaneGeometry(roadMarkerLength, roadMarkerWidth),
                        markerMaterial
                    );
                    hMarker.rotation.x = -Math.PI / 2;
                    hMarker.position.set(j * (roadMarkerLength + roadMarkerGap), 0.01, i * (blockSize + roadWidth));
                    scene.add(hMarker);

                    // Vertical road markers
                    const vMarker = new THREE.Mesh(
                        new THREE.PlaneGeometry(roadMarkerWidth, roadMarkerLength),
                        markerMaterial
                    );
                    vMarker.rotation.x = -Math.PI / 2;
                    vMarker.position.set(i * (blockSize + roadWidth), 0.01, j * (roadMarkerLength + roadMarkerGap));
                    scene.add(vMarker);
                }

                // Pedestrian crossings at intersections
                for (let j = -gridSize; j <= gridSize; j++) {
                    createPedestrianCrossing(
                        i * (blockSize + roadWidth),
                        j * (blockSize + roadWidth),
                        Math.random() > 0.5
                    );
                }
            }
        }

        function createTrafficLights() {
            // Create traffic lights at intersections
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    const x = i * (blockSize + roadWidth);
                    const z = j * (blockSize + roadWidth);

                    createTrafficLight(x + roadWidth/2 - 0.5, z + roadWidth/2 - 0.5);
                    createTrafficLight(x - roadWidth/2 + 0.5, z - roadWidth/2 + 0.5);
                }
            }
        }

        function createTrafficLight(x, z) {
            // Create pole
            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, 2.5, z);
            pole.castShadow = true;
            scene.add(pole);

            // Create traffic light housing
            const housingGeometry = new THREE.BoxGeometry(1, 2, 0.5);
            const housingMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.position.set(x, 5, z);
            housing.castShadow = true;
            scene.add(housing);

            // Create the lights (red, yellow, green)
            const lightGeometry = new THREE.CircleGeometry(0.2, 16);

            const redLight = new THREE.Mesh(
                lightGeometry,
                new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true
                })
            );
            redLight.position.set(x, 5.5, z + 0.26);
            redLight.rotation.y = Math.PI;
            scene.add(redLight);

            const yellowLight = new THREE.Mesh(
                lightGeometry,
                new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true
                })
            );
            yellowLight.position.set(x, 5, z + 0.26);
            yellowLight.rotation.y = Math.PI;
            scene.add(yellowLight);

            const greenLight = new THREE.Mesh(
                lightGeometry,
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true
                })
            );
            greenLight.position.set(x, 4.5, z + 0.26);
            greenLight.rotation.y = Math.PI;
            scene.add(greenLight);

            // Store traffic light data for animation
            trafficLights.push({
                redLight,
                yellowLight,
                greenLight,
                state: Math.floor(Math.random() * 3), // 0 = red, 1 = yellow, 2 = green
                timer: Math.random() * 5
            });
        }

        function createPedestrianCrossing(x, z, isHorizontal) {
            const crossingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.6
            });

            const stripeWidth = 0.6;
            const stripeLength = 6;
            const stripeGap = 0.4;
            const numStripes = 6;

            for (let i = 0; i < numStripes; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.PlaneGeometry(
                        isHorizontal ? stripeWidth : stripeLength,
                        isHorizontal ? stripeLength : stripeWidth
                    ),
                    crossingMaterial
                );
                stripe.rotation.x = -Math.PI / 2;

                if (isHorizontal) {
                    stripe.position.set(x + (i - numStripes/2 + 0.5) * (stripeWidth + stripeGap), 0.02, z);
                } else {
                    stripe.position.set(x, 0.02, z + (i - numStripes/2 + 0.5) * (stripeWidth + stripeGap));
                }

                scene.add(stripe);
            }
        }

        function createStreetElements() {
            // Add lampposts along roads
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    // Position at the corners of blocks
                    const x = i * (blockSize + roadWidth) + blockSize/2;
                    const z = j * (blockSize + roadWidth) + blockSize/2;

                    // Add lampposts
                    createLamppost(x + blockSize/2, z + blockSize/2);
                    createLamppost(x - blockSize/2, z + blockSize/2);
                    createLamppost(x + blockSize/2, z - blockSize/2);
                    createLamppost(x - blockSize/2, z - blockSize/2);

                    // Add trees along the sidewalks
                    if (Math.random() < 0.7) {
                        createTree(x + blockSize/2 - 1, z + Math.random() * blockSize - blockSize/2);
                    }
                    if (Math.random() < 0.7) {
                        createTree(x - blockSize/2 + 1, z + Math.random() * blockSize - blockSize/2);
                    }
                    if (Math.random() < 0.7) {
                        createTree(x + Math.random() * blockSize - blockSize/2, z + blockSize/2 - 1);
                    }
                    if (Math.random() < 0.7) {
                        createTree(x + Math.random() * blockSize - blockSize/2, z - blockSize/2 + 1);
                    }

                    // Add benches along the sidewalks
                    if (Math.random() < 0.4) {
                        createBench(x + blockSize/2 - 1, z + Math.random() * blockSize - blockSize/2, Math.random() > 0.5);
                    }
                    if (Math.random() < 0.4) {
                        createBench(x - blockSize/2 + 1, z + Math.random() * blockSize - blockSize/2, Math.random() > 0.5);
                    }
                }
            }
        }

        function createLamppost(x, z) {
            // Create lamppost base
            const baseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, 0.25, z);
            base.castShadow = true;
            scene.add(base);

            // Create pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 8, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, 4, z);
            pole.castShadow = true;
            scene.add(pole);

            // Create lamp head
            const headGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(x, 8, z);
            head.rotation.x = Math.PI / 2;
            head.castShadow = true;
            scene.add(head);

            // Create light bulb with emissive material instead of actual light
            const bulbGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const bulbMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffcc,
                emissive: 0xffffcc,
                emissiveIntensity: 0.5
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(x, 7.7, z);
            scene.add(bulb);

            // Don't add a point light for every lamppost
            // Just store the reference for day/night cycle
            bulb.userData.isStreetlight = true;
        }

        function createTree(x, z) {
            // Create tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.35, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);

            // Create tree foliage
            const foliageGeometry = new THREE.SphereGeometry(1.5, 8, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({
                color: 0x228b22,
                roughness: 0.8
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, 3, z);
            foliage.castShadow = true;
            foliage.receiveShadow = true;
            scene.add(foliage);
        }

        function createBench(x, z, isHorizontal) {
            // Create bench base
            const baseGeometry = new THREE.BoxGeometry(isHorizontal ? 2 : 0.6, 0.1, isHorizontal ? 0.6 : 2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, 0.3, z);
            base.castShadow = true;
            base.receiveShadow = true;
            scene.add(base);

            // Create bench back
            const backGeometry = new THREE.BoxGeometry(isHorizontal ? 2 : 0.1, 1, isHorizontal ? 0.1 : 2);
            const backMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const back = new THREE.Mesh(backGeometry, backMaterial);

            if (isHorizontal) {
                back.position.set(x, 0.8, z - 0.25);
            } else {
                back.position.set(x - 0.25, 0.8, z);
            }

            back.castShadow = true;
            back.receiveShadow = true;
            scene.add(back);

            // Create bench legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

            const positions = isHorizontal ?
                [[x - 0.9, z - 0.2], [x - 0.9, z + 0.2], [x + 0.9, z - 0.2], [x + 0.9, z + 0.2]] :
                [[x - 0.2, z - 0.9], [x + 0.2, z - 0.9], [x - 0.2, z + 0.9], [x + 0.2, z + 0.9]];

            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], 0.0, pos[1]);
                leg.castShadow = true;
                leg.receiveShadow = true;
                scene.add(leg);
            });
        }

        function createCars() {
            // Set car properties
            const carColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0x000000];
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            // Calculate road positions for better car placement
            const roadPositions = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                roadPositions.push(i * (blockSize + roadWidth));
            }

            // Create a smaller number of cars but ensure they're properly placed
            for (let i = 0; i < roadPositions.length; i++) {
                // Eastbound cars - ENSURE they're on the road
                for (let j = 0; j < 2; j++) {
                    const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                    // Place cars at different positions along roads
                    car.position.set(
                        -100 + Math.random() * 200, // Spread across the x-axis
                        0.6,
                        roadPositions[i] + roadWidth/4 // Precise lane positioning
                    );
                    car.rotation.y = 0; // eastbound
                    car.userData.direction = 'east';
                    car.userData.lane = 'right'; // Track lane
                    car.userData.roadIndex = i; // Track which road
                    car.userData.roadPosition = roadPositions[i]; // Store actual road position
                    cars.push(car);
                    scene.add(car);
                }

                // Westbound cars
                for (let j = 0; j < 2; j++) {
                    const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                    car.position.set(
                        100 - Math.random() * 200,
                        0.6,
                        roadPositions[i] - roadWidth/4
                    );
                    car.rotation.y = Math.PI; // westbound
                    car.userData.direction = 'west';
                    car.userData.lane = 'left';
                    car.userData.roadIndex = i;
                    car.userData.roadPosition = roadPositions[i];
                    cars.push(car);
                    scene.add(car);
                }

                // Northbound cars
                for (let j = 0; j < 2; j++) {
                    const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                    car.position.set(
                        roadPositions[i] - roadWidth/4,
                        0.6,
                        100 - Math.random() * 200
                    );
                    car.rotation.y = Math.PI / 2; // northbound
                    car.userData.direction = 'north';
                    car.userData.lane = 'left';
                    car.userData.roadIndex = i;
                    car.userData.roadPosition = roadPositions[i];
                    cars.push(car);
                    scene.add(car);
                }

                // Southbound cars
                for (let j = 0; j < 2; j++) {
                    const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                    car.position.set(
                        roadPositions[i] + roadWidth/4,
                        0.6,
                        -100 + Math.random() * 200
                    );
                    car.rotation.y = -Math.PI / 2; // southbound
                    car.userData.direction = 'south';
                    car.userData.lane = 'right';
                    car.userData.roadIndex = i;
                    car.userData.roadPosition = roadPositions[i];
                    cars.push(car);
                    scene.add(car);
                }
            }
        }

        function createCar(color) {
            // Create a car group
            const car = new THREE.Group();

            // Create car body
            const bodyGeometry = new THREE.BoxGeometry(2, 0.75, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            body.castShadow = true;
            body.receiveShadow = true;
            car.add(body);

            // Create car cabin
            const cabinGeometry = new THREE.BoxGeometry(1.2, 0.5, 0.9);
            const cabinMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.7
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(-0.1, 0.9, 0);
            cabin.castShadow = true;
            car.add(cabin);

            // Create wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

            const wheelPositions = [
                [-0.6, -0.4, 0.6], // front left
                [-0.6, -0.4, -0.6], // front right
                [0.6, -0.4, 0.6], // back left
                [0.6, -0.4, -0.6]  // back right
            ];

            wheelPositions.forEach(position => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...position);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                car.add(wheel);
            });

            // Add headlights with emissive materials instead of actual lights
            const headlightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const headlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffcc,
                emissive: 0xffffcc,
                emissiveIntensity: 0.5
            });

            const frontLight1 = new THREE.Mesh(headlightGeometry, headlightMaterial);
            frontLight1.position.set(-1, 0.4, 0.3);
            car.add(frontLight1);

            const frontLight2 = new THREE.Mesh(headlightGeometry, headlightMaterial);
            frontLight2.position.set(-1, 0.4, -0.3);
            car.add(frontLight2);

            const rearLight1 = new THREE.Mesh(
                headlightGeometry.clone(),
                new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                })
            );
            rearLight1.position.set(1, 0.4, 0.3);
            car.add(rearLight1);

            const rearLight2 = new THREE.Mesh(
                headlightGeometry.clone(),
                new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                })
            );
            rearLight2.position.set(1, 0.4, -0.3);
            car.add(rearLight2);

            // Don't add actual point lights for headlights
            // Store references to the headlight meshes instead
            car.userData.headlights = [frontLight1, frontLight2];

            return car;
        }

        function createPedestrians() {
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            // Create pedestrians on sidewalks
            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    // Sidewalk positions
                    const x = i * (blockSize + roadWidth);
                    const z = j * (blockSize + roadWidth);

                    // Add pedestrians to sidewalks
                    for (let k = 0; k < 3; k++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * blockSize/2;
                        const posX = x + Math.cos(angle) * distance;
                        const posZ = z + Math.sin(angle) * distance;

                        const pedestrian = createPedestrian();
                        pedestrian.position.set(posX, 0, posZ);
                        pedestrian.rotation.y = Math.random() * Math.PI * 2;

                        // Set pedestrian movement data
                        pedestrian.userData.speed = 0.02 + Math.random() * 0.02;
                        pedestrian.userData.direction = pedestrian.rotation.y;
                        pedestrian.userData.timer = Math.random() * 5;
                        pedestrian.userData.state = 'walking'; // walking or waiting

                        pedestrians.push(pedestrian);
                        scene.add(pedestrian);
                    }
                }
            }
        }

        function createPedestrian() {
            // Create a pedestrian group
            const pedestrian = new THREE.Group();

            // Pick a random color for the pedestrian's clothes
            const clothesColors = [0x0000ff, 0xff0000, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];
            const clothesColor = clothesColors[Math.floor(Math.random() * clothesColors.length)];

            // Create head
            const headGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xf5d0b0, // Skin tone
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            pedestrian.add(head);

            // Create body
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: clothesColor,
                roughness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            pedestrian.add(body);

            // Create legs
            const legGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.7, 8);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x0000ff, // Blue jeans
                roughness: 0.8
            });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.07, 0.7, 0);
            leftLeg.castShadow = true;
            pedestrian.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.07, 0.7, 0);
            rightLeg.castShadow = true;
            pedestrian.add(rightLeg);

            // Create arms
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
            const armMaterial = new THREE.MeshStandardMaterial({
                color: clothesColor,
                roughness: 0.8
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0.2, 1.2, 0);
            leftArm.rotation.z = Math.PI / 6;
            leftArm.castShadow = true;
            pedestrian.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(-0.2, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.castShadow = true;
            pedestrian.add(rightArm);

            return pedestrian;
        }

        function onWindowResize() {
            // Update camera aspect ratio and renderer size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateTrafficLights(deltaTime) {
            // Update traffic lights states
            trafficLights.forEach(light => {
                light.timer -= deltaTime;

                if (light.timer <= 0) {
                    // Change traffic light state
                    switch (light.state) {
                        case 0: // red to green
                            light.redLight.material.color.setHex(0x330000); // Dim red
                            light.yellowLight.material.color.setHex(0x333300); // Dim yellow
                            light.greenLight.material.color.setHex(0x00ff00); // Bright green
                            light.state = 2;
                            light.timer = 5 + Math.random() * 2; // Green light duration
                            break;
                        case 1: // yellow to red
                            light.redLight.material.color.setHex(0xff0000); // Bright red
                            light.yellowLight.material.color.setHex(0x333300); // Dim yellow
                            light.greenLight.material.color.setHex(0x003300); // Dim green
                            light.state = 0;
                            light.timer = 3 + Math.random() * 2; // Red light duration
                            break;
                        case 2: // green to yellow
                            light.redLight.material.color.setHex(0x330000); // Dim red
                            light.yellowLight.material.color.setHex(0xffff00); // Bright yellow
                            light.greenLight.material.color.setHex(0x003300); // Dim green
                            light.state = 1;
                            light.timer = 1 + Math.random(); // Yellow light duration
                            break;
                    }
                }
            });
        }

        function findTrafficLightAtIntersection(position, threshold) {
            // Find a traffic light near this position
            for (let i = 0; i < trafficLights.length; i++) {
                const light = trafficLights[i];
                const lightPos = light.redLight.position.clone();

                // Check if this traffic light is close to the given position
                if (Math.abs(lightPos.x - position.x) < threshold &&
                    Math.abs(lightPos.z - position.z) < threshold) {
                    return light;
                }
            }
            return null;
        }

        function checkIfAtIntersection(position, roadPositions, threshold) {
            // An intersection is where both x and z coordinates are near road positions
            let nearX = false;
            let nearZ = false;

            for (let i = 0; i < roadPositions.length; i++) {
                if (Math.abs(position.x - roadPositions[i]) < threshold) {
                    nearX = true;
                }
                if (Math.abs(position.z - roadPositions[i]) < threshold) {
                    nearZ = true;
                }
            }

            return nearX && nearZ;
        }

        function findNearestRoad(position, roadPositions) {
            let nearestRoadPosition = roadPositions[0];
            let minDistance = Infinity;

            for (let i = 0; i < roadPositions.length; i++) {
                const distance = Math.abs(position - roadPositions[i]);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestRoadPosition = roadPositions[i];
                }
            }

            return nearestRoadPosition;
        }

        function findNearestIntersection(position, roadPositions) {
            // Find the closest road position for x and z
            let nearestX = null;
            let nearestZ = null;
            let minDistanceX = Infinity;
            let minDistanceZ = Infinity;

            for (let i = 0; i < roadPositions.length; i++) {
                const distanceX = Math.abs(position.x - roadPositions[i]);
                const distanceZ = Math.abs(position.z - roadPositions[i]);

                if (distanceX < minDistanceX) {
                    minDistanceX = distanceX;
                    nearestX = roadPositions[i];
                }

                if (distanceZ < minDistanceZ) {
                    minDistanceZ = distanceZ;
                    nearestZ = roadPositions[i];
                }
            }

            return { x: nearestX, z: nearestZ };
        }

        function updateCars(deltaTime) {
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;
            const citySize = (blockSize + roadWidth) * gridSize;

            // Calculate road positions
            const roadPositions = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                roadPositions.push(i * (blockSize + roadWidth));
            }

            // Check if we have cars - if none, recreate them
            if (cars.length === 0) {
                console.log("No cars found! Recreating cars...");
                createCars();
                return;
            }

            // Count valid cars
            let validCarCount = 0;

            cars.forEach((car, index) => {
                // Skip invalid cars
                if (!car || !car.position) {
                    console.log("Invalid car at index", index);
                    return;
                }

                validCarCount++;

                // Ensure car has valid speed
                if (!car.userData.speed || car.userData.speed <= 0) {
                    car.userData.speed = 0.05 + Math.random() * 0.1;
                }

                // CRITICAL FIX: Force cars to stay on their assigned roads
                let speed = car.userData.speed * (1 + Math.sin(Date.now() / 1000) * 0.1);

                // Check if car has valid direction and roadPosition
                if (!car.userData.direction || !car.userData.roadPosition) {
                    console.log("Car missing direction or roadPosition");
                    // Reset car data
                    car.userData.direction = ['east', 'west', 'north', 'south'][Math.floor(Math.random() * 4)];
                    car.userData.roadPosition = roadPositions[Math.floor(Math.random() * roadPositions.length)];
                }

                // Move car based on direction and computed speed
                switch (car.userData.direction) {
                    case 'east':
                        car.position.x += speed;
                        // FORCE car to stay on its assigned road
                        car.position.z = car.userData.roadPosition + roadWidth/4;
                        break;
                    case 'west':
                        car.position.x -= speed;
                        // FORCE car to stay on its assigned road
                        car.position.z = car.userData.roadPosition - roadWidth/4;
                        break;
                    case 'north':
                        car.position.z -= speed;
                        // FORCE car to stay on its assigned road
                        car.position.x = car.userData.roadPosition - roadWidth/4;
                        break;
                    case 'south':
                        car.position.z += speed;
                        // FORCE car to stay on its assigned road
                        car.position.x = car.userData.roadPosition + roadWidth/4;
                        break;
                }

                // Check if we're at an intersection
                const isAtIntersection = checkIfAtIntersection(car.position, roadPositions, roadWidth/3);

                if (isAtIntersection && Math.random() < 0.005) { // Even lower turning probability
                    // Determine available turning directions
                    let newDirections = [];

                    if (car.userData.direction === 'east' || car.userData.direction === 'west') {
                        newDirections = ['north', 'south'];
                    } else {
                        newDirections = ['east', 'west'];
                    }

                    // Randomly select new direction
                    const newDirection = newDirections[Math.floor(Math.random() * newDirections.length)];

                    // Find nearest intersection for clean turns
                    const nearestIntersection = findNearestIntersection(car.position, roadPositions);

                    // Update car direction and position at intersection
                    switch (newDirection) {
                        case 'east':
                            car.rotation.y = 0;
                            car.userData.direction = 'east';
                            car.userData.lane = 'right';
                            car.userData.roadPosition = nearestIntersection.z;
                            car.position.x = nearestIntersection.x;
                            car.position.z = nearestIntersection.z + roadWidth/4;
                            break;
                        case 'west':
                            car.rotation.y = Math.PI;
                            car.userData.direction = 'west';
                            car.userData.lane = 'left';
                            car.userData.roadPosition = nearestIntersection.z;
                            car.position.x = nearestIntersection.x;
                            car.position.z = nearestIntersection.z - roadWidth/4;
                            break;
                        case 'north':
                            car.rotation.y = Math.PI / 2;
                            car.userData.direction = 'north';
                            car.userData.lane = 'left';
                            car.userData.roadPosition = nearestIntersection.x;
                            car.position.x = nearestIntersection.x - roadWidth/4;
                            car.position.z = nearestIntersection.z;
                            break;
                        case 'south':
                            car.rotation.y = -Math.PI / 2;
                            car.userData.direction = 'south';
                            car.userData.lane = 'right';
                            car.userData.roadPosition = nearestIntersection.x;
                            car.position.x = nearestIntersection.x + roadWidth/4;
                            car.position.z = nearestIntersection.z;
                            break;
                    }
                }

                // Handle wrapping around at city bounds
                const boundaryOffset = roadWidth;
                if (car.position.x > citySize + boundaryOffset) {
                    car.position.x = -citySize - boundaryOffset;
                }
                if (car.position.x < -citySize - boundaryOffset) {
                    car.position.x = citySize + boundaryOffset;
                }
                if (car.position.z > citySize + boundaryOffset) {
                    car.position.z = -citySize - boundaryOffset;
                }
                if (car.position.z < -citySize - boundaryOffset) {
                    car.position.z = citySize + boundaryOffset;
                }

                // ADDITIONAL SAFETY CHECK - ensure cars stay on roads
                if (car.userData.direction === 'east' || car.userData.direction === 'west') {
                    // Force car to be at exact Z coordinate for its road
                    const laneOffset = car.userData.direction === 'east' ? roadWidth/4 : -roadWidth/4;
                    car.position.z = car.userData.roadPosition + laneOffset;
                } else {
                    // Force car to be at exact X coordinate for its road
                    const laneOffset = car.userData.direction === 'south' ? roadWidth/4 : -roadWidth/4;
                    car.position.x = car.userData.roadPosition + laneOffset;
                }

                // Adjust headlight intensity based on time of day
                if (car.userData.headlights) {
                    car.userData.headlights.forEach(light => {
                        light.material.emissiveIntensity = (dayTime >= 18 || dayTime <= 6) ? 1.0 : 0.0;
                    });
                }
            });

            // If we don't have enough valid cars, recreate them
            if (validCarCount < 10) {
                console.log("Not enough valid cars, recreating...");
                recreateCars();
            }
        }

        // Add this helper function to check if a car is approaching an intersection
        function checkIfApproachingIntersection(car) {
            const gridSize = 5;
            const blockSize = 10;
            const roadWidth = 8;

            // Calculate road positions
            const roadPositions = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                roadPositions.push(i * (blockSize + roadWidth));
            }

            // Look ahead to see if approaching an intersection
            const lookaheadDistance = 6; // Distance to look ahead for intersections
            let checkPosition = car.position.clone();

            // Adjust check position based on car direction
            switch (car.userData.direction) {
                case 'east':
                    checkPosition.x += lookaheadDistance;
                    break;
                case 'west':
                    checkPosition.x -= lookaheadDistance;
                    break;
                case 'north':
                    checkPosition.z -= lookaheadDistance;
                    break;
                case 'south':
                    checkPosition.z += lookaheadDistance;
                    break;
                default:
                    console.log("Invalid car direction:", car.userData.direction);
                    return false;
            }

            // Check if the lookahead position is at an intersection
            return checkIfAtIntersection(checkPosition, roadPositions, roadWidth/2);
        }

        function updatePedestrians(deltaTime) {
            // Update pedestrian movement
            pedestrians.forEach(pedestrian => {
                const speed = pedestrian.userData.speed;

                // Update pedestrian state timer
                pedestrian.userData.timer -= deltaTime;

                if (pedestrian.userData.timer <= 0) {
                    // Change state or direction
                    if (pedestrian.userData.state === 'walking') {
                        // Randomly decide to stop or change direction
                        if (Math.random() < 0.3) {
                            pedestrian.userData.state = 'waiting';
                            pedestrian.userData.timer = 1 + Math.random() * 3; // Wait time
                        } else {
                            // Change direction
                            pedestrian.userData.direction = Math.random() * Math.PI * 2;
                            pedestrian.rotation.y = pedestrian.userData.direction;
                            pedestrian.userData.timer = 2 + Math.random() * 5; // Walk time
                        }
                    } else { // was waiting, start walking again
                        pedestrian.userData.state = 'walking';
                        pedestrian.userData.direction = Math.random() * Math.PI * 2;
                        pedestrian.rotation.y = pedestrian.userData.direction;
                        pedestrian.userData.timer = 2 + Math.random() * 5; // Walk time
                    }
                }

                // Move pedestrian if walking
                if (pedestrian.userData.state === 'walking') {
                    pedestrian.position.x += Math.sin(pedestrian.userData.direction) * speed;
                    pedestrian.position.z += Math.cos(pedestrian.userData.direction) * speed;

                    // Keep pedestrians within city bounds
                    const gridSize = 5;
                    const blockSize = 10;
                    const roadWidth = 8;
                    const citySize = (blockSize + roadWidth) * gridSize;

                    if (pedestrian.position.x > citySize) pedestrian.position.x = citySize;
                    if (pedestrian.position.x < -citySize) pedestrian.position.x = -citySize;
                    if (pedestrian.position.z > citySize) pedestrian.position.z = citySize;
                    if (pedestrian.position.z < -citySize) pedestrian.position.z = -citySize;
                }
            });
        }

        function updateDayNightCycle(deltaTime) {
            // Update time of day (24-hour cycle)
            dayTime += deltaTime * (10/60);
            if (dayTime >= 24) dayTime -= 24;

            // Get normalized time (0 to 1) where 0 is midnight and 0.5 is noon
            const normalizedTime = dayTime / 24;

            // Calculate sun position and intensity
            const sunAngle = Math.PI * 2 * normalizedTime - Math.PI/2;
            const sunHeight = Math.sin(sunAngle);

            // Get sun light
            const sunLight = scene.userData.sunLight;
            if (sunLight) {
                // Position sun
                sunLight.position.set(Math.cos(sunAngle) * 100, Math.max(sunHeight, 0.1) * 100, 0);

                // Adjust sun intensity
                let intensity = Math.max(sunHeight, 0);
                intensity = Math.pow(intensity, 0.5);
                sunLight.intensity = Math.max(intensity, 0.1);

                // Change color based on time of day
                if (dayTime > 6 && dayTime < 18) {
                    sunLight.color.setHex(0xffffff);
                } else if (dayTime > 5 && dayTime <= 6) {
                    sunLight.color.setHex(0xffddbb);
                } else if (dayTime > 18 && dayTime <= 19) {
                    sunLight.color.setHex(0xffaa88);
                } else {
                    sunLight.color.setHex(0x334455);
                }
            }

            // Adjust ambient light intensity
            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.intensity = 0.2 + Math.max(sunHeight, 0) * 0.3;
                }
            });

            // Change sky color
            if (dayTime > 6 && dayTime < 18) {
                scene.background.setHex(0x87CEEB);
            } else if ((dayTime > 5 && dayTime <= 6) || (dayTime > 18 && dayTime <= 19)) {
                scene.background.setHex(0xFFA07A);
            } else {
                scene.background.setHex(0x0A1020);
            }

            // Update building windows and streetlights (now just meshes with emissive materials)
            scene.children.forEach(child => {
                if (child instanceof THREE.Mesh) {
                    // Handle windows
                    if (child.material instanceof THREE.MeshPhongMaterial &&
                        child.geometry instanceof THREE.PlaneGeometry) {

                        if (dayTime >= 18 || dayTime <= 6) {
                            if (Math.random() < 0.6) {
                                child.material.emissive.setHex(0x555533);
                                child.material.emissiveIntensity = 0.5 + Math.random() * 0.5;
                            }
                        } else {
                            child.material.emissive.setHex(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    }

                    // Handle streetlights
                    if (child.userData.isStreetlight) {
                        if (dayTime >= 18 || dayTime <= 6) {
                            child.material.emissiveIntensity = 1.0;
                        } else {
                            child.material.emissiveIntensity = 0;
                        }
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // Update controls
            controls.update();

            // Update day-night cycle
            updateDayNightCycle(deltaTime);

            // Update traffic lights
            updateTrafficLights(deltaTime);

            // Update cars
            updateCars(deltaTime);

            // Update pedestrians
            updatePedestrians(deltaTime);

            // Render scene
            renderer.render(scene, camera);

            // Add an extra check to make sure cars exist
            if (cars.length === 0) {
                recreateCars();
            }
        }

        // Add this function to recreate cars if needed
        function recreateCars() {
            console.log("Recreating cars...");

            // Remove all existing cars from scene
            for (let i = cars.length - 1; i >= 0; i--) {
                scene.remove(cars[i]);
            }

            // Clear cars array
            cars = [];

            // Create new cars
            createCars();
        }
    </script>
</body>
</html>
